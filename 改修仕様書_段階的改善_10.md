# 改修仕様書 10: テストの追加とドキュメント整備

## 目的
コードベースにテストを追加し、ドキュメントを整備して、保守性と品質を向上させる。

## 背景
- テストが不足しており、リファクタリング時の安全性が低い
- ドキュメントが不足しており、新規参画者や将来の保守が困難
- テストフレームワークのセットアップが必要

## 実施内容

### 1. テストフレームワークのセットアップ
- **Vitest** または **Jest** のセットアップ
- React Testing Library のセットアップ
- テスト設定ファイルの作成

### 2. ユーティリティ関数のテスト
- `src/utils/env.ts` のテスト
- `src/utils/errorHandler.ts` のテスト

### 3. カスタムフックのテスト
- `src/hooks/useImageGeneration.ts` のテスト
- `src/hooks/useImageHistory.ts` のテスト
- `src/hooks/useStyleManagement.ts` のテスト

### 4. サービスのテスト
- `src/services/imageGenerationService.ts` のテスト

### 5. ドキュメントの整備
- READMEの更新
- アーキテクチャドキュメントの作成
- APIドキュメントの作成（主要関数）

## 実装詳細

### 1. テストフレームワークのセットアップ

#### `package.json` の更新
```json
{
  "scripts": {
    "test": "vitest",
    "test:ui": "vitest --ui",
    "test:coverage": "vitest --coverage"
  },
  "devDependencies": {
    "@testing-library/react": "^14.0.0",
    "@testing-library/jest-dom": "^6.1.0",
    "@testing-library/user-event": "^14.5.0",
    "vitest": "^1.0.0",
    "@vitest/ui": "^1.0.0"
  }
}
```

#### `vitest.config.ts` の作成
```typescript
import { defineConfig } from 'vitest/config';
import react from '@vitejs/plugin-react';

export default defineConfig({
  plugins: [react()],
  test: {
    environment: 'jsdom',
    globals: true,
    setupFiles: ['./src/test/setup.ts'],
  },
});
```

#### `src/test/setup.ts` の作成
```typescript
import '@testing-library/jest-dom';
import { vi } from 'vitest';

// モックの設定
global.fetch = vi.fn();
```

### 2. ユーティリティ関数のテスト例

#### `src/utils/__tests__/env.test.ts`
```typescript
import { describe, it, expect, vi, beforeEach, afterEach } from 'vitest';
import { getEnvVar, resolveSiteUrl } from '../env';

describe('env utilities', () => {
  beforeEach(() => {
    vi.clearAllMocks();
  });

  afterEach(() => {
    vi.restoreAllMocks();
  });

  describe('getEnvVar', () => {
    it('should return environment variable from import.meta.env', () => {
      const originalEnv = import.meta.env;
      import.meta.env = { ...originalEnv, VITE_TEST_KEY: 'test-value' };
      
      expect(getEnvVar('VITE_TEST_KEY')).toBe('test-value');
      
      import.meta.env = originalEnv;
    });

    it('should return undefined if variable does not exist', () => {
      expect(getEnvVar('NON_EXISTENT_KEY')).toBeUndefined();
    });
  });

  describe('resolveSiteUrl', () => {
    it('should return VITE_SITE_URL if set', () => {
      const originalEnv = import.meta.env;
      import.meta.env = { ...originalEnv, VITE_SITE_URL: 'https://example.com' };
      
      expect(resolveSiteUrl()).toBe('https://example.com');
      
      import.meta.env = originalEnv;
    });

    it('should return window.location.origin if env var is not set', () => {
      const originalEnv = import.meta.env;
      delete import.meta.env.VITE_SITE_URL;
      
      Object.defineProperty(window, 'location', {
        value: { origin: 'https://localhost:3000' },
        writable: true,
      });
      
      expect(resolveSiteUrl()).toBe('https://localhost:3000');
      
      import.meta.env = originalEnv;
    });
  });
});
```

#### `src/utils/__tests__/errorHandler.test.ts`
```typescript
import { describe, it, expect, vi } from 'vitest';
import { normalizeError, getErrorType, getUserFriendlyMessage, ErrorType } from '../errorHandler';

describe('errorHandler utilities', () => {
  describe('normalizeError', () => {
    it('should normalize Error object', () => {
      const error = new Error('Test error');
      const normalized = normalizeError(error);
      
      expect(normalized.message).toBe('Test error');
    });

    it('should normalize string error', () => {
      const normalized = normalizeError('String error');
      expect(normalized.message).toBe('String error');
    });

    it('should handle unknown error type', () => {
      const normalized = normalizeError(null);
      expect(normalized.message).toBe('不明なエラーが発生しました');
    });
  });

  describe('getErrorType', () => {
    it('should identify AUTH error', () => {
      const error = new Error('Token expired');
      (error as any).code = 'TOKEN_EXPIRED';
      
      expect(getErrorType(error)).toBe(ErrorType.AUTH);
    });

    it('should identify NETWORK error', () => {
      const error = new Error('Network error occurred');
      expect(getErrorType(error)).toBe(ErrorType.NETWORK);
    });
  });

  describe('getUserFriendlyMessage', () => {
    it('should return user-friendly message for AUTH error', () => {
      const error = new Error('Token expired');
      (error as any).code = 'TOKEN_EXPIRED';
      
      const message = getUserFriendlyMessage(error);
      expect(message).toContain('セッションの有効期限が切れました');
    });
  });
});
```

### 3. カスタムフックのテスト例

#### `src/hooks/__tests__/useImageGeneration.test.tsx`
```typescript
import { describe, it, expect, vi, beforeEach } from 'vitest';
import { renderHook, waitFor } from '@testing-library/react';
import { useImageGeneration } from '../useImageGeneration';
import * as imageGenerationService from '../../services/imageGenerationService';

vi.mock('../../services/imageGenerationService');

describe('useImageGeneration', () => {
  beforeEach(() => {
    vi.clearAllMocks();
  });

  it('should generate image successfully', async () => {
    const mockImage = { imageUrl: 'data:image/png;base64,test', base64Data: 'test' };
    vi.mocked(imageGenerationService.generateImage).mockResolvedValue(mockImage);

    const { result } = renderHook(() => useImageGeneration());

    await waitFor(async () => {
      await result.current.generate('test prompt', 'new');
    });

    expect(imageGenerationService.generateImage).toHaveBeenCalledWith({
      prompt: 'test prompt',
      mode: 'new',
      uploadedImage: undefined,
      apiKey: expect.any(String),
    });
  });

  it('should handle errors', async () => {
    const mockError = new Error('API error');
    vi.mocked(imageGenerationService.generateImage).mockRejectedValue(mockError);

    const { result } = renderHook(() => useImageGeneration());

    await waitFor(async () => {
      try {
        await result.current.generate('test prompt', 'new');
      } catch (e) {
        expect(e).toBe(mockError);
      }
    });

    expect(result.current.error).toBeTruthy();
  });
});
```

### 4. ドキュメントの整備

#### `docs/ARCHITECTURE.md` の作成
```markdown
# アーキテクチャドキュメント

## 概要
このドキュメントでは、画像生成アプリケーションのアーキテクチャについて説明します。

## ディレクトリ構造
- `src/components/`: Reactコンポーネント
- `src/hooks/`: カスタムフック
- `src/services/`: ビジネスロジック
- `src/utils/`: ユーティリティ関数
- `src/types/`: TypeScript型定義
- `src/lib/`: 外部ライブラリのラッパー

## 主要なコンポーネント
- `ImageGenerator`: メインの画像生成コンポーネント
- `PromptMaker`: プロンプト作成コンポーネント
- `ImageHistoryTable`: 画像履歴表示コンポーネント

## データフロー
1. ユーザーがプロンプトを入力
2. `useImageGeneration`フックが画像生成APIを呼び出し
3. 生成された画像を`useImageHistory`フックで保存
4. UIに画像を表示
```

#### `docs/API.md` の作成
```markdown
# APIドキュメント

## カスタムフック

### useImageGeneration
画像生成を行うカスタムフック。

**使用方法:**
```typescript
const { generate, loading, error } = useImageGeneration({
  onSuccess: (image) => {
    console.log('画像生成成功:', image);
  },
  onError: (errorMessage) => {
    console.error('エラー:', errorMessage);
  },
});

await generate('プロンプト', 'new');
```

## サービス

### imageGenerationService
画像生成APIを呼び出すサービス。

**関数:**
- `generateImage(params: GenerateImageParams): Promise<ImageGenerationResponse>`
```

## 実装手順

### ステップ1: テストフレームワークのセットアップ
1. 必要なパッケージをインストール
2. 設定ファイルを作成
3. テストが実行できることを確認

### ステップ2: ユーティリティ関数のテスト
1. 各ユーティリティ関数のテストを作成
2. カバレッジを確認
3. エッジケースをテスト

### ステップ3: カスタムフックのテスト
1. 各カスタムフックのテストを作成
2. モックを使用して外部依存を排除
3. エラーハンドリングをテスト

### ステップ4: ドキュメントの作成
1. アーキテクチャドキュメントを作成
2. APIドキュメントを作成
3. READMEを更新

## テスト要件
- ユーティリティ関数のテストカバレッジが80%以上
- カスタムフックの主要な機能がテストされている
- エラーハンドリングがテストされている
- ドキュメントが整備されている

## 影響範囲
- 新規ファイル: テストファイル（`src/**/__tests__/*.test.ts`）
- 新規ファイル: ドキュメント（`docs/*.md`）
- 更新ファイル: `package.json`, `README.md`

## 完了条件
- [ ] テストフレームワークがセットアップされている
- [ ] ユーティリティ関数のテストが作成されている
- [ ] カスタムフックのテストが作成されている
- [ ] サービスのテストが作成されている
- [ ] アーキテクチャドキュメントが作成されている
- [ ] APIドキュメントが作成されている
- [ ] READMEが更新されている
- [ ] テストが正常に実行されることを確認

## 注意事項
- テストは段階的に追加し、既存の機能を壊さないようにする
- モックを使用して外部依存を排除する
- テストカバレッジを目標として設定するが、100%を目指しすぎない
- ドキュメントは定期的に更新する

