# 改修仕様書 9: パフォーマンス最適化（メモ化と最適化）

## 目的
Reactコンポーネントの再レンダリングを最適化し、パフォーマンスを向上させる。

## 背景
- `ImageGenerator.jsx`に大量の`useState`（50以上）があり、状態管理が複雑
- `useCallback`や`useMemo`の活用が不十分
- 不要な再レンダリングが発生している可能性がある

## 実施内容

### 1. useCallback の最適化
- イベントハンドラー関数を`useCallback`でメモ化
- 依存配列を適切に設定

### 2. useMemo の最適化
- 計算コストの高い値を`useMemo`でメモ化
- 配列やオブジェクトの生成をメモ化

### 3. React.memo の適用
- 子コンポーネントに`React.memo`を適用
- プロップスの比較を最適化

### 4. 状態管理の最適化
- 関連する状態をまとめて管理
- 不要な状態を削除

## 実装詳細

### `src/ImageGenerator.jsx` の最適化例

#### 1. イベントハンドラーのメモ化
```javascript
// 既存
const handleSubmit = (e) => {
  e.preventDefault();
  generateImage();
};

// 最適化後
const handleSubmit = useCallback((e) => {
  e.preventDefault();
  generateImage();
}, [generateImage]);
```

#### 2. 計算値のメモ化
```javascript
// 既存
const promptPreview = item.prompt ? 
  (item.prompt.length > 100 ? item.prompt.substring(0, 100) + '...' : item.prompt) : 
  '-';

// 最適化後
const promptPreview = useMemo(() => {
  return item.prompt ? 
    (item.prompt.length > 100 ? item.prompt.substring(0, 100) + '...' : item.prompt) : 
    '-';
}, [item.prompt]);
```

#### 3. 子コンポーネントのメモ化
```javascript
// 画像アイテムコンポーネントをメモ化
const ImageItem = React.memo(({ image, onSelect, onDelete }) => {
  // ... コンポーネントの実装 ...
}, (prevProps, nextProps) => {
  return prevProps.image.id === nextProps.image.id &&
         prevProps.image.saved === nextProps.image.saved;
});
```

#### 4. 状態の統合
```javascript
// 既存: 複数の関連する状態
const [editingTitleId, setEditingTitleId] = useState(null);
const [editingTitle, setEditingTitle] = useState('');

// 最適化後: 状態を統合
const [editingTitle, setEditingTitle] = useState<{ id: string; title: string } | null>(null);
```

### `src/components/ImageHistoryTable.jsx` の最適化例

#### 1. フォーマット関数のメモ化
```javascript
// 既存
const formatDate = (dateString) => {
  // ... 実装 ...
};

// 最適化後
const formatDate = useCallback((dateString: string) => {
  // ... 実装 ...
}, []);
```

#### 2. フィルタリングとソートのメモ化
```javascript
// 最適化後
const sortedArchiveData = useMemo(() => {
  return [...archiveData].sort((a, b) => 
    new Date(b.created_at).getTime() - new Date(a.created_at).getTime()
  );
}, [archiveData]);
```

## 実装手順

### ステップ1: イベントハンドラーの最適化
1. すべてのイベントハンドラー関数を特定
2. `useCallback`でメモ化
3. 依存配列を適切に設定

### ステップ2: 計算値の最適化
1. 計算コストの高い値を特定
2. `useMemo`でメモ化
3. 依存配列を適切に設定

### ステップ3: 子コンポーネントの最適化
1. 頻繁に再レンダリングされる子コンポーネントを特定
2. `React.memo`を適用
3. カスタム比較関数を追加（必要に応じて）

### ステップ4: 状態管理の最適化
1. 関連する状態を特定
2. 状態を統合
3. 不要な状態を削除

## テスト要件
- パフォーマンスが向上していることを確認（React DevTools Profilerを使用）
- 既存の機能が壊れていないことを確認
- メモ化が正しく機能していることを確認

## 影響範囲
- `src/ImageGenerator.jsx`
- `src/components/ImageHistoryTable.jsx`
- `src/components/PromptMaker.tsx`（作成済みの場合）
- その他のコンポーネント（必要に応じて）

## 完了条件
- [ ] 主要なイベントハンドラーが`useCallback`でメモ化されている
- [ ] 計算コストの高い値が`useMemo`でメモ化されている
- [ ] 子コンポーネントに`React.memo`が適用されている（適切な場合）
- [ ] 状態管理が最適化されている
- [ ] パフォーマンスが向上していることを確認（React DevTools Profiler）
- [ ] 既存の機能が正常に動作することを確認

## 注意事項
- 過度なメモ化は避ける（メモ化自体にもコストがある）
- 依存配列を適切に設定し、バグを防ぐ
- パフォーマンスの改善を測定し、実際に効果があることを確認する
- プロファイリングツールを使用して、ボトルネックを特定する

## 測定方法
- React DevTools Profilerを使用して、再レンダリングの回数と時間を測定
- 最適化前後の比較を行う
- 特に、大量の画像を表示する際のパフォーマンスを確認

