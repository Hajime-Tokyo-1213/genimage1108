# 改修仕様書 6: ImageGenerator のカスタムフック抽出（履歴管理ロジック）

## 目的
`ImageGenerator.jsx`から履歴管理関連のロジックをカスタムフックに抽出し、コンポーネントの責務をさらに分離する。

## 背景
- `ImageGenerator.jsx`に履歴管理ロジックが混在している
- 履歴の読み込み、保存、削除のロジックがコンポーネント内に直接実装されている
- テストが困難で、再利用性が低い

## 実施内容

### 1. カスタムフックの作成
- **ファイル**: `src/hooks/useImageHistory.ts` を新規作成
- **内容**:
  - 履歴の読み込み
  - 履歴の保存
  - 履歴の削除
  - ページネーション

### 2. ImageGenerator.jsx の更新
- 履歴管理ロジックをカスタムフックに置き換え
- コンポーネントはUI表示に集中

## 実装詳細

### `src/hooks/useImageHistory.ts`
```typescript
import { useState, useCallback, useEffect } from 'react';
import { useAuth } from '../contexts/AuthContext';
import { persistImageHistory, removeImageHistory, persistImageArchive } from '../lib/authService';
import { supabase } from '../lib/supabaseClient';
import { handleError, logError } from '../utils/errorHandler';
import { ImageData } from '../types';

const HISTORY_PAGE_SIZE = 10;

interface UseImageHistoryOptions {
  onError?: (error: string) => void;
}

export const useImageHistory = (options: UseImageHistoryOptions = {}) => {
  const { user } = useAuth();
  const [images, setImages] = useState<ImageData[]>([]);
  const [historyPage, setHistoryPage] = useState(0);
  const [hasMoreHistory, setHasMoreHistory] = useState(false);
  const [historyLoading, setHistoryLoading] = useState(false);
  
  /**
   * 履歴を読み込む
   */
  const loadHistories = useCallback(async ({ reset = false } = {}) => {
    if (!user?.id) {
      setImages([]);
      setHasMoreHistory(false);
      return;
    }
    
    setHistoryLoading(true);
    try {
      const currentPage = reset ? 0 : historyPage;
      const from = currentPage * HISTORY_PAGE_SIZE;
      const to = from + HISTORY_PAGE_SIZE - 1;
      
      const { data, error } = await supabase
        .from('image_histories')
        .select('*')
        .eq('user_id', user.id)
        .order('created_at', { ascending: false })
        .range(from, to);
      
      if (error) {
        throw error;
      }
      
      const normalized: ImageData[] = Array.isArray(data)
        ? data.map(row => ({
            id: row.id,
            prompt: row.prompt,
            thumbnailUrl: row.thumbnail_url,
            fullImageUrl: row.full_image_url || null,
            createdAt: row.created_at,
            revision: row.revision || 0,
            title: row.title || '',
            saved: row.saved || false,
          }))
        : [];
      
      setImages(prev => {
        const next = reset ? [] : [...prev];
        normalized.forEach(item => {
          if (!next.find(existing => existing.id === item.id)) {
            next.push(item);
          }
        });
        return next.sort((a, b) => new Date(b.createdAt).getTime() - new Date(a.createdAt).getTime());
      });
      
      if (reset) {
        setHistoryPage(1);
      } else {
        setHistoryPage(prev => prev + 1);
      }
      setHasMoreHistory(normalized.length === HISTORY_PAGE_SIZE);
    } catch (err) {
      const errorMessage = handleError(err, { component: 'useImageHistory', action: 'loadHistories' });
      logError(err, { component: 'useImageHistory', action: 'loadHistories' });
      if (options.onError) {
        options.onError(errorMessage);
      }
    } finally {
      setHistoryLoading(false);
    }
  }, [user?.id, historyPage, options]);
  
  /**
   * 画像履歴を保存
   */
  const saveImageHistory = useCallback(async (image: ImageData) => {
    if (!user?.id) return;
    
    try {
      await persistImageHistory(image, supabase);
      
      // アーカイブにも保存（エラーが発生しても処理は続行）
      try {
        await persistImageArchive(image, supabase);
      } catch (archiveErr) {
        console.warn('画像アーカイブの保存に失敗しました（画像は正常に生成されています）:', archiveErr);
      }
    } catch (err) {
      const errorMessage = handleError(err, { component: 'useImageHistory', action: 'saveImageHistory', imageId: image.id });
      logError(err, { component: 'useImageHistory', action: 'saveImageHistory', imageId: image.id });
      if (options.onError) {
        options.onError(errorMessage);
      }
      throw err;
    }
  }, [user?.id, options]);
  
  /**
   * 画像履歴を削除
   */
  const deleteImageHistory = useCallback(async (imageId: string) => {
    if (!user?.id) return;
    
    try {
      await removeImageHistory(imageId, supabase);
      setImages(prev => prev.filter(img => img.id !== imageId));
    } catch (err) {
      const errorMessage = handleError(err, { component: 'useImageHistory', action: 'deleteImageHistory', imageId });
      logError(err, { component: 'useImageHistory', action: 'deleteImageHistory', imageId });
      if (options.onError) {
        options.onError(errorMessage);
      }
      throw err;
    }
  }, [user?.id, options]);
  
  /**
   * 履歴をリセットして再読み込み
   */
  const refreshHistories = useCallback(() => {
    setHistoryPage(0);
    setHasMoreHistory(false);
    loadHistories({ reset: true });
  }, [loadHistories]);
  
  // ユーザーが変更されたときに履歴を読み込む
  useEffect(() => {
    if (!user?.id) {
      setImages([]);
      setHistoryPage(0);
      setHasMoreHistory(false);
      return;
    }
    
    let isMounted = true;
    const fetchData = async () => {
      setHistoryPage(0);
      setHasMoreHistory(false);
      if (isMounted) {
        await loadHistories({ reset: true });
      }
    };
    
    fetchData();
    
    return () => {
      isMounted = false;
    };
  }, [user?.id]); // loadHistoriesを依存配列から除外（無限ループ防止）
  
  return {
    images,
    historyPage,
    hasMoreHistory,
    historyLoading,
    loadHistories,
    saveImageHistory,
    deleteImageHistory,
    refreshHistories,
  };
};
```

### `src/ImageGenerator.jsx` の更新例
```javascript
// 既存の履歴管理ロジックを削除し、カスタムフックを使用
import { useImageHistory } from './hooks/useImageHistory';

const ImageGenerator = () => {
  // ... 既存のstate定義 ...
  
  const {
    images,
    historyPage,
    hasMoreHistory,
    historyLoading,
    loadHistories,
    saveImageHistory,
    deleteImageHistory,
    refreshHistories,
  } = useImageHistory({
    onError: (errorMessage) => {
      setError(errorMessage);
    },
  });
  
  // 画像生成成功時に履歴を保存
  const { generate: generateImage } = useImageGeneration({
    onSuccess: async (image) => {
      setImages(prev => [image, ...prev]);
      setCurrentImageId(image.id);
      await saveImageHistory(image);
    },
    onError: (errorMessage) => {
      setError(errorMessage);
    },
  });
  
  // 既存の loadHistories, syncImageRecord, deleteImageRecord 関数を削除
  // カスタムフックの関数を使用
  
  // ... 残りのコンポーネント ...
};
```

## テスト要件
- カスタムフックが正しく動作することを確認
- 履歴の読み込み、保存、削除が正しく機能することを確認
- ページネーションが正しく機能することを確認
- 既存の機能が壊れていないことを確認

## 影響範囲
- `src/ImageGenerator.jsx`（履歴管理ロジックの削除とカスタムフックの使用）
- 新規ファイル: `src/hooks/useImageHistory.ts`

## 完了条件
- [ ] `src/hooks/useImageHistory.ts`が作成され、履歴管理ロジックが実装されている
- [ ] `ImageGenerator.jsx`がカスタムフックを使用するように更新されている
- [ ] 既存の履歴管理機能が正常に動作することを確認
- [ ] ページネーションが正しく機能することを確認
- [ ] エラーハンドリングが正しく機能することを確認

## 注意事項
- 既存の機能を壊さないよう、慎重にリファクタリングを行う
- 履歴の読み込みタイミングが変わらないことを確認する
- ユーザーが変更されたときの履歴読み込みが正しく動作することを確認する
- 無限ループが発生しないよう、useEffectの依存配列に注意する

