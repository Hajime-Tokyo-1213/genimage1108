# 改修仕様書 7: ImageGenerator のカスタムフック抽出（スタイル管理ロジック）

## 目的
`ImageGenerator.jsx`からスタイル管理関連のロジックをカスタムフックに抽出し、コンポーネントの責務をさらに分離する。

## 背景
- `ImageGenerator.jsx`にスタイル管理ロジックが混在している
- スタイルの読み込み、保存、削除のロジックがコンポーネント内に直接実装されている
- テストが困難で、再利用性が低い

## 実施内容

### 1. カスタムフックの作成
- **ファイル**: `src/hooks/useStyleManagement.ts` を新規作成
- **内容**:
  - スタイルの読み込み
  - スタイルの保存
  - スタイルの削除
  - デフォルトスタイルの管理

### 2. ImageGenerator.jsx の更新
- スタイル管理ロジックをカスタムフックに置き換え
- コンポーネントはUI表示に集中

## 実装詳細

### `src/hooks/useStyleManagement.ts`
```typescript
import { useState, useCallback, useEffect } from 'react';
import { useAuth } from '../contexts/AuthContext';
import { supabase } from '../lib/supabaseClient';
import { requireSession } from '../lib/supabaseClient';
import { handleError, logError } from '../utils/errorHandler';
import { Style } from '../types';

const createDefaultStyles = (): Style[] => [
  { id: '1', name: '和風アート', prompt: '日本の伝統的な和風アートスタイル、浮世絵風、美しい色彩', thumbnail: null, source: 'manual', createdAt: new Date().toISOString() },
  { id: '2', name: '未来都市', prompt: '未来の都市、サイバーパンク、ネオンライト、高層ビル', thumbnail: null, source: 'manual', createdAt: new Date().toISOString() },
  { id: '3', name: 'ファンタジー', prompt: 'ファンタジー世界、魔法、幻想的な風景、エピックな構図', thumbnail: null, source: 'manual', createdAt: new Date().toISOString() },
  { id: '4', name: '水彩画', prompt: '水彩画スタイル、柔らかい色合い、繊細な筆使い', thumbnail: null, source: 'manual', createdAt: new Date().toISOString() },
];

interface UseStyleManagementOptions {
  onError?: (error: string) => void;
}

export const useStyleManagement = (options: UseStyleManagementOptions = {}) => {
  const { user } = useAuth();
  const [styles, setStyles] = useState<Style[]>(createDefaultStyles());
  const [stylesLoading, setStylesLoading] = useState(false);
  
  /**
   * スタイルを読み込む
   */
  const loadStyles = useCallback(async () => {
    if (!user?.id) {
      setStyles(createDefaultStyles());
      return;
    }
    
    setStylesLoading(true);
    try {
      await requireSession(supabase);
      const { data, error } = await supabase
        .from('image_styles')
        .select('*')
        .eq('user_id', user.id)
        .order('created_at', { ascending: false })
        .limit(50);
      
      if (error) {
        throw error;
      }
      
      if (Array.isArray(data) && data.length > 0) {
        const normalized: Style[] = data.map(row => {
          // promptフィールドがJSON文字列の場合はYAMLオブジェクトとして復元
          let yaml: Record<string, any> | null = null;
          let prompt = row.prompt;
          
          try {
            const parsed = JSON.parse(row.prompt);
            if (typeof parsed === 'object' && parsed !== null) {
              yaml = parsed;
            }
          } catch (e) {
            // JSON解析に失敗した場合は通常のプロンプト文字列として扱う
          }
          
          return {
            id: row.id,
            name: row.name,
            prompt: prompt,
            yaml: yaml,
            thumbnail: row.thumbnail || null,
            source: row.source || 'manual',
            createdAt: row.created_at,
          };
        });
        
        setStyles(normalized);
      } else {
        setStyles(createDefaultStyles());
      }
    } catch (err) {
      const errorMessage = handleError(err, { component: 'useStyleManagement', action: 'loadStyles' });
      logError(err, { component: 'useStyleManagement', action: 'loadStyles' });
      if (options.onError) {
        options.onError(errorMessage);
      }
      setStyles(createDefaultStyles());
    } finally {
      setStylesLoading(false);
    }
  }, [user?.id, options]);
  
  /**
   * スタイルを保存
   */
  const saveStyle = useCallback(async (style: Style) => {
    if (!user?.id) return;
    
    try {
      await requireSession(supabase);
      
      const payload = {
        id: style.id,
        user_id: user.id,
        name: style.name,
        prompt: style.yaml ? JSON.stringify(style.yaml) : style.prompt,
        thumbnail: style.thumbnail || null,
        source: style.source || 'manual',
        created_at: style.createdAt || new Date().toISOString(),
      };
      
      const { data, error } = await supabase
        .from('image_styles')
        .upsert(payload, { onConflict: 'id' });
      
      if (error) {
        throw error;
      }
      
      // スタイルリストを更新
      setStyles(prev => {
        const existing = prev.find(s => s.id === style.id);
        if (existing) {
          return prev.map(s => s.id === style.id ? style : s);
        }
        return [style, ...prev];
      });
      
      return data;
    } catch (err) {
      const errorMessage = handleError(err, { component: 'useStyleManagement', action: 'saveStyle', styleId: style.id });
      logError(err, { component: 'useStyleManagement', action: 'saveStyle', styleId: style.id });
      if (options.onError) {
        options.onError(errorMessage);
      }
      throw err;
    }
  }, [user?.id, options]);
  
  /**
   * スタイルを削除
   */
  const deleteStyle = useCallback(async (styleId: string) => {
    if (!user?.id) return;
    
    try {
      await requireSession(supabase);
      const { error } = await supabase
        .from('image_styles')
        .delete()
        .eq('id', styleId)
        .eq('user_id', user.id);
      
      if (error) {
        throw error;
      }
      
      // スタイルリストから削除
      setStyles(prev => prev.filter(s => s.id !== styleId));
    } catch (err) {
      const errorMessage = handleError(err, { component: 'useStyleManagement', action: 'deleteStyle', styleId });
      logError(err, { component: 'useStyleManagement', action: 'deleteStyle', styleId });
      if (options.onError) {
        options.onError(errorMessage);
      }
      throw err;
    }
  }, [user?.id, options]);
  
  /**
   * スタイルを追加
   */
  const addStyle = useCallback(async (style: Omit<Style, 'id' | 'createdAt'>) => {
    const newStyle: Style = {
      ...style,
      id: generateUUID(),
      createdAt: new Date().toISOString(),
    };
    
    await saveStyle(newStyle);
    return newStyle;
  }, [saveStyle]);
  
  // ユーザーが変更されたときにスタイルを読み込む
  useEffect(() => {
    if (!user?.id) {
      setStyles(createDefaultStyles());
      return;
    }
    
    let isMounted = true;
    const fetchData = async () => {
      if (isMounted) {
        await loadStyles();
      }
    };
    
    fetchData();
    
    return () => {
      isMounted = false;
    };
  }, [user?.id]); // loadStylesを依存配列から除外（無限ループ防止）
  
  return {
    styles,
    stylesLoading,
    loadStyles,
    saveStyle,
    deleteStyle,
    addStyle,
  };
};

// UUID生成関数（共通化が必要な場合は別ファイルに移動）
const generateUUID = (): string => {
  return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
    const r = Math.random() * 16 | 0;
    const v = c == 'x' ? r : (r & 0x3 | 0x8);
    return v.toString(16);
  });
};
```

### `src/ImageGenerator.jsx` の更新例
```javascript
// 既存のスタイル管理ロジックを削除し、カスタムフックを使用
import { useStyleManagement } from './hooks/useStyleManagement';

const ImageGenerator = () => {
  // ... 既存のstate定義 ...
  
  const {
    styles,
    stylesLoading,
    loadStyles,
    saveStyle,
    deleteStyle,
    addStyle,
  } = useStyleManagement({
    onError: (errorMessage) => {
      setError(errorMessage);
    },
  });
  
  // 既存の loadStyles, syncStyleRecord, deleteStyleRecord 関数を削除
  // カスタムフックの関数を使用
  
  // ... 残りのコンポーネント ...
};
```

## テスト要件
- カスタムフックが正しく動作することを確認
- スタイルの読み込み、保存、削除が正しく機能することを確認
- デフォルトスタイルが正しく表示されることを確認
- 既存の機能が壊れていないことを確認

## 影響範囲
- `src/ImageGenerator.jsx`（スタイル管理ロジックの削除とカスタムフックの使用）
- 新規ファイル: `src/hooks/useStyleManagement.ts`

## 完了条件
- [ ] `src/hooks/useStyleManagement.ts`が作成され、スタイル管理ロジックが実装されている
- [ ] `ImageGenerator.jsx`がカスタムフックを使用するように更新されている
- [ ] 既存のスタイル管理機能が正常に動作することを確認
- [ ] デフォルトスタイルが正しく表示されることを確認
- [ ] エラーハンドリングが正しく機能することを確認

## 注意事項
- 既存の機能を壊さないよう、慎重にリファクタリングを行う
- スタイルの読み込みタイミングが変わらないことを確認する
- ユーザーが変更されたときのスタイル読み込みが正しく動作することを確認する
- 無限ループが発生しないよう、useEffectの依存配列に注意する
- YAMLデータの処理が正しく動作することを確認する

